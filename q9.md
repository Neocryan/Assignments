### Question 9
#### ($a$)
(i) Is the produced Kronecker graph connected? 

b+c = 0.79<1 unconnected

(ii) Does the graph have a giant connected component of size $\Theta(n)$? Provide _theoretical justification_ of your answers. You can also confirm your answers by examining the properties of the graph (e.g., computing the actual size of the GCC).

(a+b)(b+c) =0.9875, so no gcc as $\Theta(n)$

#### ($b$)
Describe three structural properties which show that the produced graph looks similar (qualitatively or even quantitatively) to the CA-GrQc network. For each of those properties you should examine how they look like in both the original CA-GrQc network and produced Kronecker graph

The Kronecker graph is also power law distribution:
![](https://lh3.googleusercontent.com/9zAXhuN9qp701mKyrZRugC_5X1NTrhcFPCVYQ17f_ch_gCnLNn2foO3DTrHxXXid9wmWteJz8B8UoQ)
![enter image description here](https://lh3.googleusercontent.com/ZCWRwAP4enXMAFXKjgcGSLS3c_dW1tyZYe93Pmby7m9WIO2-wGA5-avttb09LZkkBniqc7g8FsiUhw)

![enter image description here](https://lh3.googleusercontent.com/OIxHqRXVVF-7sj630Jf4nHtFt2VnS5tZAj9O5qGFhJvLTr_TANW20SvJN8XTedqxvPsBGsB6yOR2XA)

We can find that the degree, triangle, eigenvalue and diameter distribution is very similar to the original network and follow a power law distribution.

Also, the GCC of kron_graph have 93.4% of total nodes, and 97.31% of total edges.



---------
code:
```python
A_1 = np.matrix([[0.99,0.26],[0.26,0.53]])
def kron(a,t):
    x = a
    for i in range(t):
        x = np.kron(x,a)
    return x
b = kron(A_1,10)
b_adj =b - np.random.random(b.shape)
with open('b_edge.txt','w') as be:
    for i in range(b.shape[0]):
        for j in range((b.shape[0])):
            if b_adj[i,j] >=0 :
                be.write('{}\t{}\n'.format(i,j))
kron_graph = nx.read_edgelist('b_edge.txt')
print(nx.is_connected(kron_graph))
nx.number_of_nodes(gcc_b), nx.number_of_nodes(gcc_b) / nx.number_of_nodes(kron_graph)
nx.number_of_edges(gcc_b), nx.number_of_edges(gcc_b) / nx.number_of_edges(kron_graph)
tri_kr = np.array(list(nx.triangles(kron_graph).values()))
kr_tri_count = np.array([[x,list(tri_kr).count(x)] for x in set(tri_kr)])

plt.scatter(np.log10(kr_tri_count[:,0]),np.log10(kr_tri_count[:,1]))
plt.title('log-log triangle distribution')
dgr_kr = np.array(list(nx.degree(kron_graph))).astype('int')[:,1]
kr_dgr_count = np.array([[x,list(dgr_kr).count(x)] for x in set(dgr_kr)])
# plt.loglog(kr_dgr_count[:,0],kr_dgr_count[:,1])
plt.scatter(np.log10(kr_dgr_count[:,0]),np.log10(kr_dgr_count[:,1]))
plt.title('log-log degree distribution')
kr_dia_count = np.array([[x,list(dia_distri).count(x)] for x in set(dia_distri)])
# plt.loglog(kr_dgr_count[:,0],kr_dgr_count[:,1])
plt.scatter(np.log10(kr_dia_count[:,0]),np.log10(kr_dia_count[:,1]))
plt.title('log-log diameter distribution')
```



<!--stackedit_data:
eyJoaXN0b3J5IjpbNzg4MzU5MTI5XX0=
-->